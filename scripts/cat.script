require "scripts.utils"

local g_idle_animations = { "Idle01", "Idle02", "Idle03" }
local g_idle_animations_hash = {}
for _, animation in ipairs(g_idle_animations) do
	table.insert(g_idle_animations_hash, hash(animation))
end
local g_left_id = hash("left")
local g_right_id = hash("right")
local g_jump_id = hash("jump")
local g_contact_point_response = hash("contact_point_response")
local g_level_layer = hash("level")
local g_gravity = -9.81 * 100

function init(self)
	-- Add initialization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
	msg.post("#", "acquire_input_focus")
	msg.post("@render:", "use_camera_projection")
 
	self.acceleration = vmath.vector3(0, 0, 0)
	self.gravity_scale = 1
	self.velocity = vmath.vector3(0, 0, 0)
	self.max_accel_x = 1000
	self.min_speed_x = 10
	self.max_speed = vmath.vector3(200, 500, 0)
	self.drag = 0.05
	self.is_grounded = false
	self.jump_speed = 600
	self.max_jump_time = 0.2
	self.jump_time = 1000
	self.jump_down = false
	self.jump = false
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

local function check_ground_helper(self, offset)
	-- Raycast from the character's position downward
	local from = go.get_position()
	from.x = from.x + offset
	local to = from - vmath.vector3(0, 10, 0)  -- Adjust the distance as needed

	local result = physics.raycast(from, to, { hash("level") }, false)
	if result ~= nil then
		-- Collider detected below the character
		return true
	else
		-- No collider detected
		return false
	end
end

local function check_ground(self)
	if check_ground_helper(self, 0) then
		return true
	elseif check_ground_helper(self, -12) then
		return true
	elseif check_ground_helper(self, 12) then
		return true
	end

	return false
end

function fixed_update(self, dt)

	local was_grounded = self.is_grounded
	
	self.is_grounded = check_ground(self)

	if (not was_grounded) and (self.is_grounded) then
		particlefx.play("#fall") 
		sound.play("#fall_sound")
	end

	self.jump_time = self.jump_time + dt
	
	-- Set gravity to acceleration
	local accel = vmath.vector3(self.acceleration)
	if not self.is_grounded then
		accel.y = accel.y + g_gravity * self.gravity_scale
	end
	
	-- Update velocity
	self.velocity = self.velocity + accel * dt

	-- Jump
	if self.jump_down and self.is_grounded then
		self.velocity.y = self.jump_speed
		self.jump_time = 0
		self.gravity_scale = 1
		sound.play("#jump_sound")
	elseif self.jump and self.jump_time < self.max_jump_time then
		self.gravity_scale = 1
	elseif not self.is_grounded then
		self.gravity_scale = 5
	else
		self.gravity_scale = 1
	end
	
	-- Add drag
	self.velocity = apply_drag(self.velocity, self.drag, dt)

	-- Clamp velocity
	self.velocity.x = clamp(self.velocity.x, -self.max_speed.x, self.max_speed.x)
	self.velocity.y = clamp(self.velocity.y, -self.max_speed.y, self.max_speed.y)
	
	-- Hard stop near 10 velocity
	if self.acceleration.x == 0 and math.abs(self.velocity.x) < self.min_speed_x then
		self.velocity.x = 0
	end	
	
	local position = go.get_position()
	position = position + self.velocity * dt

	go.set_position(position)	

	local current_animation = go.get("#sprite", "animation")
	if (math.abs(self.velocity.y) > 2) then
		if (self.velocity.y < 0) then
			sprite.play_flipbook("#sprite", "Fall")
		else
			sprite.play_flipbook("#sprite", "Jump")
		end
	else	
		if (math.abs(self.velocity.x) > 75) then
			if current_animation ~= hash("Run") then
				sprite.play_flipbook("#sprite", "Run")
			end
			sprite.set_hflip("#sprite", self.velocity.x > 0)		
		elseif (math.abs(self.velocity.x) > self.min_speed_x) then
			if current_animation ~= hash("Walk") then
				sprite.play_flipbook("#sprite", "Walk")
			end
		else
			if not table_contains(g_idle_animations_hash, current_animation) then
				sprite.play_flipbook("#sprite", g_idle_animations[math.random(#g_idle_animations)])	
			end
		end
	end
	sprite.set_hflip("#sprite", self.velocity.x > 0)		
end

function on_message(self, message_id, message, sender)
	if message_id == g_contact_point_response and
	   message.other_group == g_level_layer then
		local position = go.get_position()
		position = position + message.normal * message.distance
		go.set_position(position)

		-- Remove velocity in this direction
		proj_velocity = vmath.dot(self.velocity, message.normal) * message.normal
		new_velocity = self.velocity - proj_velocity

		self.velocity = new_velocity
	end
end

function on_input(self, action_id, action)
	if action_id == g_right_id then
		self.acceleration.x = self.max_accel_x
		if action.released then
			self.acceleration.x = 0
		end
	elseif action_id == g_left_id then
		self.acceleration.x = -self.max_accel_x
		if action.released then
			self.acceleration.x = 0
		end
	elseif action_id == g_jump_id then
		self.jump_down = action.pressed
		self.jump = not action.released
	end
end
